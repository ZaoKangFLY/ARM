#include "Tim_Init.h"

int16_t Encoder1_Overflow_Count = 0;
int16_t Encoder2_Overflow_Count = 0;
/* 使能对应PWM通道定时器 */
void TIMx_PWM_enable(void)
{
#if PID_ASSISTANT_EN
	is_motor_en=1;
#endif
    Big1_PWM_ENABLE();
    Big2_PWM_ENABLE();
    Small1_PWM_ENABLE();
    Small2_PWM_ENABLE();
	
#if 0   
    Ce_PWM1_ENABLE();    
    Ce_PWM2_ENABLE();  
#endif
}
/* 失能对应PWM通道定时器 */
void TIMx_PWM_disable(void)
{
	is_motor_en=0;
	Big1_PWM_DISABLE();
    Big2_PWM_DISABLE();
    Small1_PWM_DISABLE();
    Small2_PWM_DISABLE();
	
#if 0   
	Ce_PWM1_DISABLE() 
	Ce_PWM2_DISABLE() 
#endif
}
/* 使能编码器定时器 */
void TIMx_econder_enable(void)
{
	/* 清零计数器 */
	Big_TIM_SETCOUNTER();
    Small_TIM_SETCOUNTER();
	/*清空标志位*/
    __HAL_TIM_CLEAR_IT(&Big_Encoder_htim,TIM_IT_UPDATE);
    __HAL_TIM_CLEAR_IT(&Small_Encoder_htim,TIM_IT_UPDATE);
	/*计时器更新中断*/
    __HAL_TIM_ENABLE_IT(&Big_Encoder_htim,TIM_IT_UPDATE);
    __HAL_TIM_ENABLE_IT(&Small_Encoder_htim,TIM_IT_UPDATE);	
	
	Big_Encoder_ENABLE(); 
    Small_Encoder_ENABLE();


   
}
/*使能定时器中断*/	
void TIMx_basic_enable(void)
{
	Basic_TIM_ENABLE();	
#if PID_ASSISTANT_EN
    uint32_t temp = GET_BASIC_TIM_PERIOD();     // 计算周期，单位ms  
	set_computer_value(SEND_PERIOD_CMD, CURVES_CH1, &temp, 1);     // 给通道 1 发送目标值
	set_computer_value(SEND_PERIOD_CMD, CURVES_CH2, &temp, 1);     // 给通道 1 发送目标值
	set_computer_value(SEND_PERIOD_CMD, CURVES_CH3, &temp, 1);     // 给通道 1 发送目标值
	set_computer_value(SEND_PERIOD_CMD, CURVES_CH4, &temp, 1);     // 给通道 1 发送目标值
#endif
}

/*定时器中断回调函数中进行PWM*/
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) 
{
	if(htim==(&Big_Encoder_htim))
    {
        /* 判断当前计数器计数方向 */
        if(__HAL_TIM_IS_TIM_COUNTING_DOWN(&Big_Encoder_htim))
        {   /* 下溢 */
            Encoder1_Overflow_Count--;
        }
        else
        {   /* 上溢 */
            Encoder1_Overflow_Count++;
        }	
    }  
    else if(htim==(&Small_Encoder_htim))
    {
		//printf("************************************\r\n");
        /* 判断当前计数器计数方向 */
        if(__HAL_TIM_IS_TIM_COUNTING_DOWN(&Small_Encoder_htim))
        {   /* 下溢 */
            Encoder2_Overflow_Count--;
        }
        else
        {   /* 上溢 */
            Encoder2_Overflow_Count++;
        }	
    }  
    else if(htim==(&Basic_htim))//1ms进一次中断
	{       
		Motor_Big_Set_Speed(Big_Speed);
		Motor_Small_Set_Speed(Small_Speed);
//		Motor_CeTui_Set(ROL_Angle);     
		
//Motor_Big_Set_Position(Big_Position);
// Motor_Small_Set_Position(Small_Position);
		
//		static int i =0;
//		i++;
//		if(i==1000)
//		{
//			Usart_SendString((uint8_t *)"1");
//			i=0;
//		}
	       
    }


}



